# Техническое задание: Frontend клиента Avito Agent

**Стек:** HTML5, CSS3, Vanilla JavaScript (ES6+).
**Зависимости:** Разрешена только одна внешняя библиотека — `marked.js` (через CDN) для красивого отображения Markdown разметки в сообщениях.
**Принцип:** Single Page Application (SPA) без перезагрузки, но на простых файлах.

## 1. Структура проекта
Файловая структура должна быть плоской и понятной:

```text
/frontend
  ├── index.html        # Каркас страницы
  ├── styles.css        # Все стили
  ├── js/
  │    ├── app.js       # Точка входа и основная логика (Polling, Init)
  │    ├── api.js       # Обертки над fetch запросами к API
  │    ├── render.js    # Функции отрисовки (сообщения, лоты, статус)
  │    └── utils.js     # Форматирование дат, цен, escaping HTML
```

---

## 2. Разметка (index.html)

Верстка должна быть построена на Flexbox для адаптивности.
**Основные блоки:**

1.  **Header (`header`):**
    *   Логотип/Название (Avito Agent).
    *   Индикатор статуса (`span`): "Готов", "Поиск...", "Думает...".
    *   Кнопка "Новый поиск" (`button`): Сбрасывает текущий ID и начинает новое исследование.

2.  **Main (`main`):**
    *   **Контейнер чата (`#chat-container`):** Область с прокруткой, где появляются сообщения.
    *   **Область ввода (`#input-area`):**
        *   `textarea` (с авто-высотой, если получится, или просто фикс).
        *   Кнопка отправки (`#send-btn`).

3.  **Templates (`<template>`):**
    Использовать тег `<template>` для заготовок сообщений, чтобы не писать HTML внутри JS строк.
    *   `#msg-user-tpl`: Шаблон сообщения пользователя.
    *   `#msg-bot-tpl`: Шаблон сообщения бота.
    *   `#lot-card-tpl`: Шаблон карточки товара (картинка, цена, название).

---

## 3. Логика работы (JavaScript)

### 3.1. Управление состоянием (State Management)
В `app.js` должен быть простой объект состояния:
```javascript
const state = {
    mr_id: null,        // ID текущего исследования (Market Research)
    messages: [],       // Локальная копия истории сообщений
    currentStatus: 'CHAT', // Текущий статус (CHAT, SEARCHING_QUICK и т.д.)
    lastUpdate: 0       // Timestamp последнего обновления
};
```

### 3.2. Взаимодействие с API (`api.js`)
Реализовать функции, возвращающие Promise:
*   `createMarketResearch(query)`: POST запрос для старта.
*   `getMarketResearch(id)`: GET запрос для получения истории и статуса.
*   `sendMessage(id, text)`: POST запрос сообщения.

**Важно:** Все запросы должны иметь обработку ошибок (`try/catch`). Если сервер упал — выводить `alert` или красивое уведомление (toast).

### 3.3. Цикл обновлений (Polling)
Так как мы не используем WebSockets/SSE для простоты:
1.  Реализовать функцию `pollState()`.
2.  Использовать `setInterval` (раз в 2-3 секунды).
3.  **Логика поллинга:**
    *   Запрашиваем `getMarketResearch(state.mr_id)`.
    *   Сравниваем длину массива сообщений с `state.messages.length`.
    *   Если сообщений стало больше -> вызываем `renderNewMessages()`.
    *   Если изменился `status` -> обновляем индикатор в шапке.
    *   Если статус `SEARCHING...`, блокируем кнопку отправки и пишем "Агент ищет...".

### 3.4. Отрисовка (`render.js`)
*   `renderMessage(msg)`:
    *   Клонирует шаблон.
    *   Если роль `user` -> ставит класс `.message-user` (справа).
    *   Если роль `assistant` -> ставит класс `.message-bot` (слева).
    *   Текст сообщения прогонять через `marked.parse(text)` для поддержки жирного текста, списков и ссылок.
    *   Вставляет в `#chat-container`.
    *   Автоматически скроллит контейнер вниз.

*   `renderStatus(status)`:
    *   Меняет цвет индикатора (Зеленый - CHAT, Желтый - SEARCHING).

---

## 4. Стилизация (CSS)

Дизайн должен быть "чистым" и функциональным.
*   **Шрифт:** Inter или Roboto.
*   **Цвета:**
    *   Фон чата: Светло-серый (#f5f5f5).
    *   Сообщение юзера: Синий (#007bff), текст белый.
    *   Сообщение бота: Белый (#ffffff), текст черный, тень (box-shadow).
*   **Карточки товаров:** Должны выглядеть как плитки.
    *   Image (cover, фиксированная высота).
    *   Title (bold, truncation ...).
    *   Price (большой шрифт).
*   **Анимации:** Простой спиннер при ожидании ответа.

---

## 5. Сценарий работы (User Flow) для разработчика

1.  **Загрузка страницы:**
    *   Показываем приветственный экран.
    *   Пользователь вводит первый запрос (например, "найди ноутбук") в Input.
    *   JS делает `createMarketResearch`.
    *   JS сохраняет `mr_id`.
    *   JS запускает `setInterval`.

2.  **Общение:**
    *   Пользователь пишет уточнение.
    *   JS делает `sendMessage`. Инпут очищается.
    *   Сообщение рендерится сразу (оптимистичный UI) или ждем поллинга (надежнее для v1).

3.  **Получение ответа:**
    *   Поллинг видит новое сообщение от `assistant`.
    *   Если в тексте есть Markdown разметка — она превращается в HTML.
    *   Если в тексте есть ссылки на картинки (формат `![img](url)`), они отображаются.

---

## 6. Требования к качеству кода (Code Quality)

1.  **Никакого `var`**, только `const` и `let`.
2.  **Изоляция:** Глобальные переменные сведены к минимуму (все в `state`).
3.  **Безопасность:** При рендеринге HTML из Markdown убедиться, что не исполняются скрипты (хотя `marked.js` по умолчанию безопасен, но стоит помнить про XSS).
4.  **Расширяемость:** Код рендеринга сообщения должен быть готов к тому, что в будущем `msg` будет содержать не только `content` (строка), но и массив `items` (товары). Для этого сейчас сделать проверку: `if (msg.items) renderItems(msg.items)`.

## 7. План расширения (на будущее, учитывать сейчас)
*   Оставить место в CSS для отображения "Галереи" под сообщением.
*   В `render.js` оставить пустую функцию `renderVisualAttachments()`, которую мы наполним, когда включим поддержку картинок.
